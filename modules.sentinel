#
# This module enforces the usage of required modules 
# while prohibiting the creation of the resource those 
# modules contain. For instance, if a required module 
# creates a VPC in AWS, the consumer will not be allowed 
# to create their own VPC. This reduces risk as well as 
# module maintenance. 
#

import "tfconfig/v2" as tfconfig
import "strings"
import "json"
import "http"

param provider
param base_url

output = {}

# Get all referenced modules
# get_modules = func() {
#     modules = []
#     for tfconfig.module_calls as mod {
#         # We just want to get the short name of the module
#         modname = strings.split(tfconfig.module_calls[mod].source, "/")
#         # Add the module to our list
#         append(modules, modname[2])
#     }
#     return modules
# }

# These modules are required to be used
req = http.request(base_url + "/list/required-modules/" + provider)
res = json.unmarshal(http.get(req).body)
required_modules = res

# Get all resources
module_resources = func() {
    missing_modules = []
    all_modules = []
    prohibited_resources = []
    failed_resources = []
    errors = []
    passed = true

    # get a list of resource being used in the required modules
    for tfconfig.resources as res {
        modaddr = tfconfig.resources[res].module_address
        if modaddr != "" {
            modfull = strings.split(modaddr, ".")
            modname = modfull[1]
            if modname not in all_modules {
                append(all_modules, modname)
            }
            if modname in required_modules {
                append(prohibited_resources, tfconfig.resources[res].type)
            }
        }
    }

    for all_modules as mod {
        if mod not in required_modules {
            append(missing_modules, mod)
            append(errors, "Missing required modules")
            passed = false
        }
    }

    # get a list of resources not in the required modules
    # and compare that to resource that are in the required modules
    for tfconfig.resources as res {
        restype = tfconfig.resources[res].type
        modname = tfconfig.resources[res].module_address
        if modname != "" {
            modfull = strings.split(modname, ".")
            modname = modfull[1]
        }
        if modname not in required_modules {
            if restype in prohibited_resources {
                append(failed_resources, restype)
                append(errors, "Attempt to create prohibited resources")
                passed = false
            }
        }
    }

    output = {
        "required_modules": required_modules,
        "missing_modules": missing_modules,
        "all_modules": all_modules,
        "prohibited_resources": prohibited_resources,
        "failed_resources": failed_resources,
        "status": passed,
        "errors": errors,
    }

    return passed
}

# # Store modules in a global variable
# selected_modules = get_modules()

# print("Required modules:")
# print(required_modules)

# print("Selected modules:")
# print(selected_modules)

print(json.marshal(output))

# If true, we passed!
main = rule { module_resources() }
